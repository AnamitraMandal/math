[/
  Copyright 2017 Nick Thompson

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:norms Norms]

[heading Synopsis]

``
#include <boost/math/tools/norms.hpp>

namespace boost{ namespace math{ namespace tools {

    template<class Container>
    auto l0_pseudo_norm(Container const & c);

    template<class ForwardIterator>
    auto l0_pseudo_norm(ForwardIterator first, ForwardIterator last);

    template<class Container>
    auto l1_norm(Container const & c);

    template<class ForwardIterator>
    auto l1_norm(ForwardIterator first, ForwardIterator last);

    template<class Container>
    auto l2_norm(Container const & c);

    template<class ForwardIterator>
    auto l2_norm(ForwardIterator first, ForwardIterator last);

    template<class Container>
    auto sup_norm(Container const & c);

    template<class ForwardIterator>
    auto sup_norm(ForwardIterator first, ForwardIterator last);

    template<class Container>
    auto lp_norm(Container const & c);

    template<class ForwardIterator>
    auto lp_norm(ForwardIterator first, ForwardIterator last, p);

    template<class Container>
    auto total_variation(Container const & c);

    template<class ForwardIterator>
    auto total_variation(ForwardIterator first, ForwardIterator last);

}}}
``

[heading Description]

The file `boost/math/tools/norms.hpp` is a set of facilities for computing scalar values traditionally useful in numerical analysis from vectors.

Our examples use `std::vector<double>` to hold the data, but this not required.
In general, you can store your data in an Eigen array, and Armadillo vector, `std::array`, and for many of the routines, a `std::forward_list`.
These routines are usable in float, double, long double, and Boost.Multiprecision precision, as well as their complex extensions whenever the computation is well-defined.
For certain operations (total variation, for example) integer inputs are supported.

[heading \u2113[super \u221E] norm]

Computes the supremum norm of a dataset:

    std::vector<double> v{-3, 2, 1};
    double sup = boost::math::tools::sup_norm(v.cbegin(), v.cend());
    // sup = 3

    std::vector<std::complex<double>> v{{0, -8}, {1,1}, {-3,2}};
    double sup = boost::math::tools::sup_norm(v.cbegin(), v.cend());
    // sup = 8

Supports real, integral, and complex arithmetic.
Container must be forward iterable and is not modified.

[heading \u2113[super /p/] norm]

    std::vector<double> v{-8, 0, 0};
    double sup = boost::math::tools::lp_norm(v.cbegin(), v.cend(), 7);
    // sup = 8

    std::vector<std::complex<double>> v{{1, 0}, {0,1}, {0,-1}};
    double sup = boost::math::tools::sup_norm(v.cbegin(), v.cend(), 3);
    // sup = cbrt(3)

Supports both real and complex arithmetic.
The container must be forward iterable and the contents are not modified.

[heading \u2113[super 0] pseudo-norm]

Counts the number of non-zero elements in a container.

    std::vector<double> v{0,0,1};
    size_t count = boost::math::tools::l0_pseudo_norm(v.begin(), v.end());
    // count = 1

Supports real, integral, and complex numbers.
The container must be forward iterable and the contents are not modified.
Note that this measure is not robust against numerical noise and is therefore not as useful as (say) the Hoyer sparsity in numerical applications.
Works will real, complex, and integral inputs.

[heading \u2113[super 1] norm]

The \u2113[super 1] norm is a special case of the \u2113[super /p/] norm, but is much faster:

    std::vector<double> v{1,1,1};
    double l1 = boost::math::tools::l1_norm(v.begin(), v.end());
    // l1 = 3

Requires a forward iterable input, does not modify input data, and works with real, integral, and complex numbers.

[heading \u2113[super 2] norm]

The \u2113[super 2] norm is again a special case of the \u2113[super /p/] norm, but is much faster:

    std::vector<double> v{1,1,1};
    double l1 = boost::math::tools::l2_norm(v.begin(), v.end());
    // l1 = sqrt(3)

Requires a forward iterable input, does not modify input data, and works with real and complex numbers.

[heading Total Variation]

    std::vector<double> v{1,1,1};
    double tv = boost::math::tools::total_variation(v.begin(), v.end());
    // no variation in v, so tv = 0.
    v = {0,1};
    double tv = boost::math::tools::total_variation(v.begin(), v.end());
    // variation is 1, so tv = 1.
    std::vector<int> v{1,1,1};
    int tv = boost::math::tools::total_variation(v);

The total variation only supports real numbers and integers.
All the constituent operations to compute the total variation are well-defined for complex numbers,
but the computed result is not meaningful; a 2D total variation is more appropriate.
The container must be forward iterable, and the contents are not modified.

As an aside, the total variation is not technically a norm, since /TV(v) = 0/ does not imply /v = 0/.
However, it satisfies the triangle inequality and is absolutely 1-homogeneous, so it is a seminorm, and hence is grouped with the other norms here.

[heading References]

* Higham, Nicholas J. ['Accuracy and stability of numerical algorithms.] Vol. 80. Siam, 2002.
* Mallat, Stephane. ['A wavelet tour of signal processing: the sparse way.] Academic press, 2008.
* Hurley, Niall, and Scott Rickard. ['Comparing measures of sparsity.] IEEE Transactions on Information Theory 55.10 (2009): 4723-4741.
* Jensen, Arne, and Anders la Cour-Harbo. ['Ripples in mathematics: the discrete wavelet transform.] Springer Science & Business Media, 2001.

[endsect]
[/section:norms Norms]
